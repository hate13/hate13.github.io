---
title: ACM常用算法
key: 980713e7e4adb5d20d75696b9693bae0
tags: 学习
---

[ACM](https://zh.wikipedia.org/zh-sg/%E5%9B%BD%E9%99%85%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B) 打酱油选手，简单复习一下已经忘了很久的常用算法

![acm](http://118.24.108.205:8086/pic/blog/acm.jpg)

<!--more-->

# 基础算法

## 枚举

有些问题不好直接求解答案，但是若给出答案，很容易验证答案是否正确，此时就可以枚举答案范围内的所有值进行验证

## 模拟

### 简单

### 复杂

## 递归

## 分治

## 前缀和

前缀和是一种预处理手段，在某些情况能大大降低查询的时间复杂度

ps: 下标从 1 开始要好写一点，不用刻意处理数组边界

### 一维

``` c
// 一维：sum[i] 表示前 i 项的和
// 递推：sum[i] = sum[i - 1] + a[i]
// 查询：sum[l..r] = sum[1..r] - sum[1..l - 1]
void pre_solve_one() {
    int n = 5;
    int data[] = {0, 1, 5, 3, 2, 6}; // 1..5

    int sum[N] = {0};
    for (int i = 1; i <= n; i++) {
        sum[i] = sum[i - 1] + data[i];
    }

    // sum[1..5] = sum[5] - sum[0] = 17
    // sum[3..5] = sum[5] - sum[2] = 11
    printf("%d %d\n", sum[5], sum[5] - sum[2]);
}
```

### 二维

``` c
#include <stdio.h>
#define N 100

// 二维：sum[i][j] 表示从左上角 (1,1) 开始到坐标 (i, j) 之间的元素和
// 递推：sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + a[i][j] - sum[i - 1][j - 1]
// 查询：sum[(x1,y1)..(x2,y2)] = sum[x2][y2] - sum[x1-1][y2] - sum[x1][y2-1] + sum[x1-1][y1-1]
//
// 举例：
// (1,1) | (1,2) (1,3) (1,4)
// (2,1) | (2,2) (2,3) (2,4)
// (3,1) | (3,2) (3,3) (3,4)
// -------------------
// (4,1) | (4,2) (4,3) (4,4)
// (5,1) | (5,2) (5,3) (5,4)
//
// sum[(4,2)..(5,3)]
//  = sum[(1,1)..(5,3)] - sum[(1,1)..(3,3)] - sum[(1,1)..(5,1)] + sum[(1,1)..(3,1)]
//  = sum[5][3] - sum[3][3] - sum[5][1] + sum[3][1]
void pre_solve_two() {
    int n = 5, m = 4;
    int data[][5] = {
            {},
            {0, 1,  2,  3,  4},
            {0, 5,  6,  7,  8},
            {0, 9,  10, 11, 12},
            {0, 13, 14, 15, 16},
            {0, 17, 18, 19, 20},
    };
    int sum[N][N] = {0};
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + data[i][j] - sum[i - 1][j - 1];
        }
    }
    printf("%d %d\n", sum[5][4], sum[5][3] - sum[3][3] - sum[5][1] + sum[3][1]); // 210 66
}
```

### 树

``` c
// 树上前缀和：sum[i] 表示从根节点到节点 i 之间的路径权值和
// 如果是边权，sum(x..y) = sum[x] + sum[y] - 2 * sum[lca(x, y)]
// 如果是点权，sum(x..y) = sum[x] + sum[y] - 2 * sum[fa[lca(x, y)]] + data[lca(x, y)]
//
// 举例：
//     1
//    / \
//   2   3
//  / \
// 4   5
//      \
//       6
void pre_solve_tree() {

}
```

## 倍增

## 二指针

## 二分

### 二分查找

在网上搜索二分查找，可以看到各式各样的写法，其中一些写法是有问题的，参考：[二分查找有几种写法](https://www.zhihu.com/question/36132386)

推荐下面这种“左开右闭”的写法，另外注意二分查找的前提是数组有序

``` c
#include <stdio.h>

// 二分查找
// 若存在返回下标，否则返回-1
// 分析
//   如果 key = data[m]，表示找到了直接返回
//   如果 key < data[m]，表示 key 可能位于左区间 [l, m)
//   如果 key > data[m]，表示 key 可能位于右区间 [m + 1, r)
int binarySearch(int data[], int n, int key) {
    int l = 0, r = n;
    while (l < r) {
        int m = (l + r) >> 1; // 防溢出：l + ((r - l) >> 1)
        if (key == data[m]) {
            return m;
        } else if (key < data[m]) {
            r = m;
        } else {
            l = m + 1;
        }
    }
    return -1;
}

// 返回 >= key 的首个元素下标
// 区间左开右闭，比如：[l......m......r)
// 分析：
//   如果 key <= data[m]，首个大于等于 key 的首个元素一定位于 [l, m]，继续查找左区间 [l, m)。如果最终 [l, m) 中的元素都小于 key 咋办？没关系，这会使得二分过程中 l 不断向右 (即 m) 逼近，最终 "l = m + 1" 使得 l = m
//   如果 key >  data[m]，左区间 [l, m] 都比 key 小，不可能了，继续查找右区间 [m+1, r)
//
// 这种情况下，可能最后不存在 key，不断逼近，l 停止的位置就是刚好大于 key 的数的位置
int lowerBound(int data[], int n, int key) {
    int l = 0, r = n;
    while (l < r) {
        int m = (l + r) >> 1;
        if (key <= data[m]) {
            r = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}

// 返回 > key 的首个元素下标
// 区间左开右闭，比如：[l......m......r)
// 分析：
//   如果 key >= data[m]，答案显然不可能位于 [l, m]，继续查找右区间 [m+1, r)
//   如果 key  < data[m]，则答案一定位于 [l, m]，继续查找左区间 [l, m)。如果最终 [l, m) 中的元素都小于 key 咋办？同上
//
// 在这种情况下，停止时 l 一定是 key 后面，可能存在 key，也可能不存在 key
int upperBound(int data[], int n, int key) {
    int l = 0, r = n;
    while (l < r) {
        int m = (l + r) >> 1;
        if (key >= data[m]) {
            l = m + 1;
        } else {
            r = m;
        }
    }
    return l;
}

int main() {
    int data[] = {1, 2, 3, 3, 3, 6, 6, 8, 9, 10};
    printf("%d %d\n", binarySearch(data, 10, 5), binarySearch(data, 10, 8)); // -1 7
    printf("%d %d\n", lowerBound(data, 10, 3), lowerBound(data, 10, 5)); // 2 5
    printf("%d %d\n", upperBound(data, 10, 3), upperBound(data, 10, 6)); // 5 7
    return 0;
}
```

### 二分答案

参考上面的[枚举](https://hate13.com/2020/01/10/ACM%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.html#%E6%9E%9A%E4%B8%BE)，如果答案满足一定单调性，则可以通过二分优化

``` c
#include <stdio.h>

bool check(int n) {
    return true;
}

int find(int l, int r) {
    while (l < r) {
        int m = (l + r) >> 1;
        if (check(m)) {
           // ans = m; // 可能有时不太好处理这种左开右闭写法的边界问题，干脆直接加一个 ans 变量记录答案
            r = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}
```

## 排序

### 冒泡排序

``` c
/*
 * 冒泡排序
 *
 * 时间复杂度 O(n^2)，空间复杂度 O(1)，稳定排序
 * 思路：从小到大排序，每趟从左到右遍历，遍历过程中比较相邻两个元素，如果左边大于右边则交换，结束时归位一个最大值到右边，重复 n-1 趟使得所有值归位
 * 优化：可以检查每趟遍历是否发生过交换，如果一次交换都没有，表示数组已经有序了，可以提前终止外层循环，如果一开始就有序则一趟遍历就结束了
 *
 * 举例：
 * 1 8 2 9 5 7 6 3 4
 *
 * 1 2 8 9 5 7 6 3 4  9 > 5，交换
 * 1 2 8 5 9 7 6 3 4  9 > 7，交换
 * 1 2 8 5 7 9 6 3 4  9 > 6，交换
 * 1 2 8 5 7 6 9 3 4  9 > 3，交换
 * 1 2 8 5 7 6 3 9 4  9 > 4，交换
 * 1 2 8 5 7 6 3 4 9  归位元素 9，看起来就好像把 9 从左边冒泡到右边
 * 
 * 1 2 8 5 7 6 3 4 9  8 > 5，交换
 * 1 2 5 8 7 6 3 4 9  8 > 7，交换
 * 1 2 5 7 8 6 3 4 9  8 > 6，交换
 * 1 2 5 7 6 8 3 4 9  8 > 3，交换
 * 1 2 5 7 6 3 8 4 9  8 > 4，交换
 * 1 2 5 7 6 3 4 8 9  归位元素 8
 *
 * ...
 *
 */

#include <stdio.h>

void bubble_sort(int data[], int n) {
    for (int j = 0; j < n - 1; j++) {         // 循环 n-1 次，每次循环归位一个元素到 n-j-1 位置(下标从 0 开始)
        for (int i = 0; i < n - j - 1; i++) { // 每趟冒泡时只需要考虑 [0, n-j-1] 区间，因为后面的元素都已排序，完成后归位到 n-j-1 处
            if (data[i] > data[i + 1]) {
                int t = data[i];
                data[i] = data[i + 1];
                data[i + 1] = t;
            }
        }
    }
}

int main() {
    int a[] = {1, 8, 2, 9, 5, 7, 6, 3, 4};
    bubble_sort(a, 9);
    for (int i = 0; i < 9; i++) {
        printf("%d ", a[i]);
    }
    printf("\n");
    return 0;
}
```

### 选择排序

``` c
/*
 * 选择排序
 *
 * 时间复杂度 O(n^2)，空间复杂度 O(1)，不稳定排序
 * 思路：从小到大排序，每趟循环直接选择一个最小值元素，然后放到对应位置即可
 * 对比：和冒泡不同的是选择排序是找到最值元素和直接交换，而不是从左到右冒泡过去，相对来说选择排序交换次数更小，但冒泡排序可以通过检测是否交换进行一点小优化
 * 参考：https://www.zhihu.com/question/21027517
 *
 * 举例：
 * 7 8 2 9 5 1 6 3 4
 *
 * 1 8 2 9 5 7 6 3 4  第一趟循环找到最小值为 1，交换 7 和 1，归位 1
 * 1 2 8 9 5 7 6 3 4  第二趟循环找到最小值为 2，交换 8 和 2，归位 2
 * 1 2 3 9 5 7 6 8 4  第三趟循环找到最小值为 3，交换 8 和 3，归位 3
 * 1 2 3 4 5 7 6 8 9  第四趟循环找到最小值为 4，交换 9 和 4，归位 4
 *
 * ...
 */

#include <stdio.h>

void select_sort(int data[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int min_k = i;
        for (int j = i + 1; j < n; j++) {
            if (data[j] < data[min_k]) { // 判断右边是否有更小的元素
                min_k = j;
            }
        }
        if (min_k != i) { // 如果右边有更小的元素，则交换归位第 i 个元素
            int t = data[i];
            data[i] = data[min_k];
            data[min_k] = t;
        }
    }

}

int main() {
    int a[] = {7, 8, 2, 9, 5, 1, 6, 3, 4};
    select_sort(a, 9);
    for (int i = 0; i < 9; i++) {
        printf("%d ", a[i]);
    }
    printf("\n");
    return 0;
}

```

### 插入排序

### 归并排序

``` c
/*
 * 归并排序
 *
 * 稳定时间复杂度 O(nlogn)，空间复杂度 O(n)，稳定排序
 * 思路：利用分治的思路，将数组不断二分，先排序左半部分，再排序右半部分，最后二路归并
 *
 * 举例：
 * [1 3 5 7] + [2 4 6 8 9] => [1 2 3 4 5 6 7 8 9]
 */

#include <stdio.h>
#define N 10010
int tmp[N]; // 临时保存归并结果，每次归并 [l, m, r] 时即占用 [l, r] 区间

void merge(int data[], int l, int m, int r) {
    int i = l, j = m + 1, k = l;
    while (i <= m && j <= r) tmp[k++] = data[i] < data[j] ? data[i++] : data[j++];
    while (i <= m) tmp[k++] = data[i++];       // 左半部分更长
    while (j <= r) tmp[k++] = data[j++];       // 右半部分更长
    for (k = l; k <= r; k++) data[k] = tmp[k]; // 归并完成后赋值到原数据
}

void merge_sort(int data[], int l, int r) {
    if (l < r) {                    // l = r 代表一个元素
        int m = (l + r) >> 1;
        merge_sort(data, l, m);     // 左半部分排序
        merge_sort(data, m + 1, r); // 右半部分排序
        merge(data, l, m, r);       // 合并两部分
    }
}

int main() {
    int a[] = {1, 8, 2, 9, 5, 7, 6, 3, 4};
    merge_sort(a, 0, 8);
    for (int i = 0; i < 9; i++) {
        printf("%d ", a[i]);
    }
    printf("\n");
    return 0;
}
```

### 快速排序

### 推排序

### 置换排序

# 贪心

# 搜索

## DFS

一种图遍历的算法，它的思想是从图中的起点开始，沿着一条路径走到底，如果发现不能到达目标解，那就返回到上一个节点，然后搜索另一条路径

例题：在一个 n * m 的迷宫中，'#' 为墙，'-' 为路，求起点 S 到终点 E 的最小步数

``` cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define min(a, b) ((a) < (b) ? (a) : (b))
#define N 1010
#define M 1010

int ans;
int n, m;
int sx, sy;
int ex, ey;
char mpt[N][M];
int dir[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };

void dfs(int x, int y, int step) {
    if (x == ex && y == ey) { // 终点
        ans = min(ans, step);
        return;
    }
    if (step >= ans) return; // 超过当前最小步数，剪枝
    for (int i = 0; i < 4; i++) {
        int tx = x + dir[i][0];
        int ty = y + dir[i][1];
        if (tx >= 0 && tx < n && ty >= 0 && ty < m && mpt[tx][ty] != '#') {
            char t = mpt[tx][ty];
            mpt[tx][ty] = '#';     // 标记为墙，避免重复访问，这里也可以单独使用一个 vis 数组用于标记
            dfs(tx, ty, step + 1); // 递归搜索
            mpt[tx][ty] = t;       // 回溯，尝试另外的路径
        }
    }
}

/*
 * 5 5
 * S-###
 * -----
 * ##---
 * E#---
 * ---##
 */
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i++) {
        scanf("%s", mpt[i]);
        for (int j = 0; j < m; j++) {
            if (mpt[i][j] == 'S') {
                sx = i;
                sy = j;
            } else if (mpt[i][j] == 'E') {
                ex = i;
                ey = j;
            }
        }
    }
    ans = n * m - 1;
    dfs(sx, sy, 0);
    printf("%d\n", ans);
    return 0;
}
```

## BFS

和 DFS 不一样的是，BFS 是一种分层搜索，从起点开始，一层层向外搜索，直到终点
同一层的节点到起点的距离相等，由于是通过队列维护遍历过程，所以上一层节点遍历完成之后才会遍历下一层节点

``` cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
#define N 1010
#define M 1010

struct Node {
    int x, y, d;
};

struct Queue {
    int front, rear;
    Node nodes[N];
};

int n, m;
int sx, sy;
int ex, ey;
char mpt[N][M];
bool vis[N][M];
int dir[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };

// 使用 STL 实现
int bfs() {
    queue<Node> q;
    Node now, next;
    now.x = sx;
    now.y = sy;
    now.d = 0;
    vis[sx][sy] = 1;
    q.push(now); // 起点进队
    while (!q.empty()) {
        now = q.front();
        q.pop();
        if (now.x == ex && now.y == ey) { // 到达终点，返回
            return now.d;
        }
        for (int i = 0; i < 4; i++) {
            next = now;
            next.x += dir[i][0];
            next.y += dir[i][1];
            next.d++;
            if (next.x >= 0 && next.x < n && next.y >=0 && next.y < m && mpt[next.x][next.y] != '#' && !vis[next.x][next.y]) {
                vis[next.x][next.y] = 1;
                q.push(next);             // 进队下个节点
            }
        }
    }
    return -1; // 无法到达终点
}

// 使用数组实现
// 记录层数的两种方式：
// - 每个节点中记录当前层数
// - 使用两个变量记录每层节点的数量
int bfs_2() {
    Queue q;
    Node now, next;
    memset(vis, 0, sizeof(vis));
    int now_step_num = 1, next_step_num = 0, step = 0;

    now.x = sx;
    now.y = sy;
    now.d = 0;
    vis[sx][sy] = 1;
    q.front = q.rear = 0;
    q.nodes[++q.rear] = now; // 起点进队
    while (q.front != q.rear) {
        now = q.nodes[++q.front]; // 出队
        // printf(">>> now: %d %d %d %d\n", now.x, now.y, now.d, step);
        if (now.x == ex && now.y == ey) {
            return now.d;
        }
        for (int i = 0; i < 4; i++) {
            next = now;
            next.x += dir[i][0];
            next.y += dir[i][1];
            next.d++;
            if (next.x >= 0 && next.x < n && next.y >=0 && next.y < m && mpt[next.x][next.y] != '#' && !vis[next.x][next.y]) {
                vis[next.x][next.y] = 1;
                q.nodes[++q.rear] = next; // 入队
                next_step_num++;
            }
        }
        now_step_num--;
        if (now_step_num == 0) { // 若当前层出队完了，换到下一层，下一层从0计数
            now_step_num = next_step_num;
            next_step_num = 0;
            step++;
        }
    }
    return -1; // 无法到达终点
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i++) {
        scanf("%s", mpt[i]);
        for (int j = 0; j < m; j++) {
            if (mpt[i][j] == 'S') {
                sx = i;
                sy = j;
            } else if (mpt[i][j] == 'E') {
                ex = i;
                ey = j;
            }
        }
    }
    printf("%d\n", bfs());
    printf("%d\n", bfs_2());
    return 0;
}
```

## 记忆化

# 动态规划

## 背包问题

## 区间DP

## 树形DP

## 状压DP

## 数位DP

# 数学

## GCD

## 素数筛

## 容斥原理

## 鸽巢原理

## 快速幂

### 乘法快速幂

``` c
#include <stdio.h>

// 快速计算 a^n，复杂度 O(logN)
//
// 一般循环遍历相乘需要做 n 次乘法，如果 n 太大就比较慢了
// 那么可以做一个变换，将 n 用二进制表示，如：a^13 = a^(1101)_2 = a^8 * a^4 * 1 * a^1
// 这样就可以优化计算了，将 n 转化为二进制，从低位到高位，如果这一位为1，则乘上 a，同时每次循环 a 都自乘一次
int quick_pow(int a, int b) {
    int ret = 1;
    while (b) {
        if (b & 1) ret *= a;
        a *= a;
        b >>= 1;
    }
    return ret;
}

int main() {
    printf("%d\n", quick_pow(3, 13));
    return 0;
}
```

### 矩阵快速幂

## 扩展欧几里得

## 逆元

## 中国剩余定理

## 卢卡斯定理

## 欧拉函数

## 高斯消元

## 莫比乌斯反演

# 数据结构

## 栈

## 链表

## 队列

## 堆

## 字典树

``` cpp
// 字典树：顾名思义，就是一棵像字典一样的树
// 字典树可用于高效查找字符串或字符串前缀，时间复杂度：O(n)

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 1000010
#define M 26

int sz;       // sz 表示待分配的字典树节点下标
int ch[N][M]; // ch 用于存储字典树，如 ch[2][3] 表示字典树中第 2 个节点的第 3 个子节点
int val[N];   // val 用于存储字典树对应节点的附属信息

// 初始化字典树
// 0 为根节点，一个虚拟的空节点
void init() {
    // memset(ch[0], 0, sizeof(ch[0]));
    sz = 1;
}

int get_id(char c) { return c - 'a'; }

// 插入新的串到树中
void insert(char *s) {
    int p = 0;
    int l = strlen(s);
    for (int i = 0; i < l; i++) { // 依次遍历字符串，从根节点开始，如果不存在即新建节点
        int id = get_id(s[i]);
        if (!ch[p][id]) {
            ch[p][id] = sz++;
        }
        p = ch[p][id];
        val[p]++; // 以 s[0..i] 为前缀的字符串出现次数+1
    }
}

// 在树中查找前缀串
int find(char *s) {
    int p = 0;
    int l = strlen(s);
    for (int i = 0; i < l; i++) {
        int id = get_id(s[i]);
        if (!ch[p][id]) return 0; // 不存在
        p = ch[p][id];
    }
    return val[p]; // 返回指定前缀串出现的次数
}

/*
 * abc
 * abcde
 * qwer
 *
 * a
 * abc
 * abcde
 * empty
 */
int main() {
    char s[12];
    init();
    while (gets(s), strlen(s)) {
        insert(s);
    }
    while (gets(s)) {
        cout << find(s) << endl;
    }
    return 0;
}
```

## 分块

## RMQ

## 线段树

## 树状数组

## 并查集

### 简单

``` cpp
// 并查集是一种树形的数据结构，可以方便地维护集合的合并和查询问题
// 举例：给出 N 组朋友关系，朋友的朋友即朋友，判断其中 a 和 b 是否是朋友关系

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define N 5010

// f[x] 表示节点 x 所在集合的根节点
int f[N];

// 初始化并查集
// 初始化时每个集合只有自身一个节点
void init(int n) {
    for (int i = 0; i < n; i++) f[i] = i;
}

// 查询节点 x 所在集合的根节点
// 这里涉及到路径压缩
//
// 假设有如图所示的集合关系，查询节点 6 所在集合根节点时会不断往上直到找到根节点 1，这可能会在集合路径较长时导致查询缓慢
//
//        1
//      / | \
//     2  3  4
//    /
//   5
//  /
// 6
//
// 路径压缩是指在查询根节点时将起所在路径上的节点变为根节点的直接子节点。即：
//
//      1
//  / / | \ \
// 2 3  4 5  6
//
// 当再次查询节点 6/5/2 所在集合根节点时，只用往上查询一层即可得到根节点 1，降低了时间复杂度
//
int find(int x) {
    if (x != f[x]) f[x] = find(f[x]);
    return f[x];
}

// 合并 x 和 y 节点所在的两个集合
void union_2(int x, int y) {
    x = find(x);
    y = find(y);
    if (x != y) { // 这里选择序号小的节点为合并后的集合根节点，也可以自定义一个估价函数，比如按秩合并
        if (x > y) f[x] = y;
        else f[y] = x;
    }
}

int judge(int x, int y) {
    return find(x) == find(y);
}

int main() {
    init(6);

    union_2(0, 1);
    union_2(2, 3);
    union_2(4, 5);

    printf("%d %d %d\n", judge(0, 1), judge(0, 3), judge(1, 5)); // 1 0 0

    union_2(1, 3);
    union_2(3, 5);

    printf("%d %d %d\n", judge(0, 1), judge(0, 3), judge(1, 5)); // 1 1 1
    return 0;
}
```

### 带权

## 树状数组

## 单调队列-栈
### 单例队列
#### 介绍
单调队列是一种广泛应用的数据结构，它能够动态地维护序列中的最值

#### 实例
设计一个队列，使得能够处理三种操作：
- PUSH 100  将元素100添加到队尾
- MAX  查询当前队列中元素的最大值
- POP  移除队首元素

#### 暴力解法
最简单的做法就是每次查询时遍历当前队列中的所有元素，比较得到最大值，复杂度：O(N\*K)，K为每次查询时队列的平均长度  
比如：

|Operation|Comment（左边为队首，单调递减队列，队首为最大值）|
|---|:-----|
|PUSH 300|[300]|
|MAX|(1) 遍历得到当前最大值为300|
|PUSH 200|[300,200]|
|MAX|(2) 遍历得到当前最大值为300|
|PUSH 100|[300,200,100]|
|MAX|(3) 遍历得到当前最大值为300|
|POP|[200,100]|
|MAX|(4) 遍历得到当前最大值为200|
|PUSH 400|[200,100,400]|
|MAX|(5) 遍历得到当前最大值为400|
|POP|[100,400]|
|MAX|(6) 遍历得到当前最大值为400|

显然这不是最优解  
先看第(1)(2)(3)(4)次查询，其实是可以省略一些比较运算的，因为进队的元素是单调递减的，无需比较直接返回队首元素即可（即使中间有出队操作）  
再看第(5)次查询，插入的400破坏了前面的单调关系，是否可以将队列中的已有的200、100直接出队（因为这俩已经没用了，只要400被插入到队列中，最大值就永远不会是200或100，即使400被移除队列，200或100肯定先于400被移除），然后再将400进队，这样最大值就是队首元素了  
综合上面两种情况：如果插入的元素满足单调关系，直接将元素插入队尾，否则先将队尾元素出队，再插入新的元素，查询时直接返回队首元素即可

#### 单调队列
单调队列相对于普通队列而言，需要维护了一种单调关系，队首始终保存的是当前队列中元素的最值  
每个元素仅进队一次，仅出队一次，在元素插入队尾前，需要先和队尾元素进行比较，如果关系符合单调顺序，则直接插入队尾，否则需要先移除队尾元素再进行插入，使得始终保持单调关系  
复杂度：O(N)

|Operation|Comment|
|---|:-----|
|PUSH 300|[300]|
|MAX|无需遍历，直接返回队首元素300|
|PUSH 200|[300,200] 200小于300，直接插入队尾|
|MAX|无需遍历，直接返回队首元素300|
|PUSH 100|[300,200,100] 100小于200，直接插入队尾|
|MAX|无需遍历，直接返回队首元素300|
|POP|[200,100] 移除队首元素|
|MAX|无需遍历，直接返回队首元素200|
|PUSH 400|[400]，400不小于100，移除队尾元素100，继续比较，400不小于200，再移除队尾元素200，最后将400插入队尾|
|MAX|无需遍历，直接返回队首元素400|
|POP|[400]，注意这里POP原本出队的是元素200，所以这里不需要真正执行出队操作。实际实现时可以给每个进队元素内置一个in_id，每次出队维护一个out_id++，如果当前out_id和队首元素的id相等，才真正执行出队操作|
|MAX|无需遍历，直接返回队首元素400|

##### 代码
``` cpp
// 未经测试，仅供参考
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 1000010

struct item {
    int id, val;
} q[MAXN], tp;

int main() {
    char op[10];
    int front = 0, rear = 0;
    int in = 0, out = 0; // in, out表示进队、出队编号
    while (scanf("%s", op) && strcmp(op, "END")) {
        if (strcmp(op, "PUSH") == 0) { // 进队，单调递减
            scanf("%d", &tp.val);
            tp.id = in++;
            while (rear > front && tp.val >= q[rear].val) rear--;
            q[rear++] = tp;
        } else if (strcmp(op, "MAX") == 0) { // 查询
            if (front == rear) {
                cout << -1 << endl;
            } else {
                cout << q[front].val << endl;
            }
        } else { // 出队，如果id在当前队首就出队
            if (out == q[front].id) {
                front++;
            }
            out++;
        }
    }
    return 0;
}
```

#### 题目
- FZU 1894  模板题
- POJ 2823  模板题
- HDU 3415
- HDU 3530
- POJ 3061

### 单调栈

#### 介绍

和单调队列类似，栈内元素始终保持单调性，不同的是单调栈只能在栈顶操作

将一个元素压入单调栈时，为了维护栈的单调性，需要和栈顶元素进行比较，栈顶始终保存的是当前栈中元素的最值

比如单调递减栈（从栈底到栈顶单调递减），每个元素进栈时，如果栈顶元素比当前元素大则直接进栈，否则需要先不断弹出栈顶元素直到栈顶元素大于当前元素，然后再压入当前元素

利用这一性质，可以利用单调栈：

- 求每个元素左边第一个比它大（单调递减）/ 小（单调递增）的元素
- 求每个元素左边的元素中以当前元素为右边第一个比其大（单调递减）或小（单调递增）的元素列表

#### 实例

|Operation|Comment（右边为栈顶，从栈底到栈顶单调递减，栈顶为最小值）|
|---|:-----|
|6|[6]|
|10|[10] 10大于6，弹出栈顶元素6，压入元素10|
|3|[10,3] 3小于10，压入元素3，3|
|7|[10,7] 7大于3，弹出栈顶元素3，压入元素7<br />比如这里可以得出：7左边第一个比7大的元素是栈顶元素10|
|4|[10,7,4] 4小于7，压入元素4|
|12|[12] 12大于10,7,4 弹出栈顶元素，压入元素12<br />比如这里可以得出：12左边的元素中，有三个元素10,7,4(递减序列)，他们右边的第一个比其大的元素是12|
|2|[12,2] 2小于12，压入元素2|

|Operation|Comment（右边为栈顶，从栈底到栈顶单调递增，栈顶为最大值）|
|---|:-----|
|6|[6]|
|10|[6,10] 10大于6，压入元素10|
|3|[3] 3小于6,10，弹出栈顶元素，压入元素3|
|7|[3,7] 7大于3，压入元素7|
|4|[3,4] 4小于7，弹出栈顶元素7，压入元素4|
|12|[3,4,12] 12大于4，压入元素12|
|2|[2] 2小于3,4,12，弹出栈顶元素，压入元素2|

#### 代码

``` cpp
// 未经测试，仅供参考
#include <iostream>
#include <cstdio>
#include <cstring>
#include <stack>
#include <algorithm>
using namespace std;

struct item {
    int id, val;
} tp;

// 7 6 10 3 7 4 12 2
int main() {
    int n;
    stack<item> s;
    while (scanf("%d", &n) != EOF) {
        for (int i = 0; i < n; i++) {
            tp.id = i;
            scanf("%d", &tp.val);
            while (s.size() > 0 && tp.val >= s.top().val) { // 从栈底到栈顶单调递减
                s.pop();
            }
            cout << "left first: " << (s.size() > 0 ? s.top().val : -1) << ", left size: " << s.size() << endl;
            s.push(tp);
        }
    }
    return 0;
}
```

#### 题目

- POJ 3250 模板题
- POJ 2796
- HDU 1506
- POJ 2559


## 树链剖分

## 划分树

## Treap

## Splay

## 主席树

# 图论

## 邻接表与邻接矩阵 

图常用的两种存储方式即：邻接矩阵和邻接表

### 邻接矩阵

``` cpp
// 邻接矩阵，遍历时间复杂度：O(N^2)

#include <stdio.h>
#include <string.h>
#define N 110

int n;
int vis[N];
int mpt[N][N];

void init(int nn) {
    n = nn;
    memset(mpt, -1, sizeof(mpt));
    memset(vis, 0, sizeof(vis));
}

void add(int u, int v) {
    mpt[u][v] = 1;
}

void dfs(int u) {
    printf("%d\n", u);
    vis[u] = 1;
    for (int v = 1; v <= n; v++) {
        if (mpt[u][v] && !vis[v]) {
            dfs(v);
        }
    }
}

int main() {
    init(5);
    add(1, 2);
    add(1, 3);
    add(1, 4);
    add(2, 5);
    add(5, 3);
    add(3, 1);
    dfs(1);
    return 0;
}
```

### 邻接表

#### 数组

``` cpp
// 邻接表的数组实现与遍历，遍历时间复杂度：O(E)

#include <stdio.h>
#include <string.h>

#define N 100010
#define M 200010

struct Edge {
    int u, v, w;     // 边的起点、重点、权值
    int next;        // 与节点相连的边的集合中下一条边的序号
};

int tot;             // tot 表示 edge 数组中待分配的边的下标
int head[N];         // head[i] 表示与节点 i 相连的的第一条边的下标
struct Edge edge[M]; // 存储边
int vis[N];

// 初始化
void init() {
    tot = 0;
    memset(head, -1, sizeof(head));
    memset(vis, 0, sizeof(vis));
}

// 新建 u->v 的边，边的下标为 tot
// 使用头插法，所以对节点 u 相连的边进行遍历时和添加边时的顺序相反
void add(int u, int v, int w) {
    edge[tot].u = u;
    edge[tot].v = v;
    edge[tot].w = w;
    edge[tot].next = head[u];
    head[u] = tot++;          // 将当前新加的边保存到 head[u]，已有的边接在 edge[head[u]].next
}

// 如果是树的话，使用 pre 记录父节点防止重复遍历
void dfs1(int u, int pre) {
    printf("%d\n", u);
    for (int i = head[u]; i != -1; i = edge[i].next) {
        int v = edge[i].v;
        if (v != pre) {
            dfs1(v, u);
        }
    }
}

// 如果是图的话(特指带环图)，就必须使用 vis 标记
void dfs2(int u) {
    printf("%d\n", u);
    vis[u] = 1;
    for (int i = head[u]; i != -1; i = edge[i].next) {
        int v = edge[i].v;
        if (!vis[v]) {
            dfs2(v);
        }
    }
}

int main() {
    init();
    add(1, 2, 1);
    add(1, 3, 1);
    add(1, 4, 1);
    add(2, 5, 1);
    dfs1(1, 1);

    puts("\n");

    init();
    add(1, 2, 1);
    add(1, 3, 1);
    add(1, 4, 1);
    add(2, 5, 1);
    add(5, 3, 1);
    add(3, 1, 1);
    dfs2(1);
    return 0;
}
```

#### Vector

``` cpp
// 邻接数组写起来稍微有点麻烦
// 很多时候可以直接使用 STL 中的 vector 实现

#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
#define N 100010

int vis[N];
vector<int> vec[N];

void init(int n) {
    memset(vis, 0, sizeof(vis));
    for (int i = 1; i <= n; i++) {
        vec[i].clear();
    }
}

// 添加双向边
void add(int u, int v) {
    vec[u].push_back(v);
    vec[v].push_back(u);
}

// 遍历
void dfs(int u) {
    printf("%d\n", u);
    vis[u] = 1;
    for (int i = 0; i < vec[u].size(); i++) {
        int v = vec[u][i];
        if (!vis[v]) {
            dfs(v);
        }
    }
}

int main() {
    init(5);
    add(1, 2);
    add(1, 3);
    add(1, 4);
    add(2, 5);
    add(5, 3);
    add(3, 1);
    dfs(1);
    return 0;
}
```

## 生成树

### 最小生成树

最小生成树(Minimum Spanning Tree，MST)指在无向连通图中，边权和最小的生成树

#### Prim

``` cpp
/*
 * 最小生成树(Minimum Spanning Tree，MST)指在无向连通图中，边权和最小的生成树
 *
 * Prim 算法，时间复杂度：O(n^2)
 * (1) 将图的节点分为两部分，一部分是已在 mst 的点，一部分是待加入 mst 的点
 * (2) 随机选择一个节点 v1 作为起点 加入 mst，每次迭代选择距离 mst 最近的点 v2，将对应边加入 mst 中，同时更新未在 mst 中的点到 mst 的最小距离，迭代 n - 1 次即可
 */

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define INF 0x3f3f3f3f
#define N 1010

int mpt[N][N];  // mpt[i][j] 表示节点 i 到节点 j 的距离，INF 表示不可达
int dis[N];     // dis[i] 表示节点 i 离 mst 的最小距离(即距离 mst 中最近的点的距离)，已加入 mst 中的点对应 dis 为 -1

void init() {
    memset(mpt, INF, sizeof(mpt)); // 初始化邻接矩阵所有边权值为 INF，表示相互都不可达
}

// 任选一个起点
int prim(int s, int n) {
    int ans = 0;
    for (int j = 1; j <= n; j++) { // 初始化 dis 为起点到各个点的距离
        dis[j] = mpt[s][j];
    }
    dis[s] = -1;
    for (int i = 1; i < n; i++) { // 迭代 n - 1 次
        int min_k = INF, k;
        for (int j = 1; j <= n; j++) {
            if (dis[j] != -1 && dis[j] < min_k) { // 每次迭代选择一个距离 mst 最近的点加入 mst
                min_k = dis[k = j];
            }
        }
        if (min_k == INF) { // 构不成 mst，非无向连通图
            return -1;
        }
        dis[k] = -1;
        ans += min_k; // 将对应边加入 mst，更新 mst 权值和
        for (int j = 1; j <= n; j++) { // 更新其他点到 mst 中的最小距离(即 mst 中加入节点 k 后的变化)
            if (dis[j] != -1 && mpt[k][j] < dis[j]) {
                dis[j] = mpt[k][j];
            }
        }
    }
    return ans;
}

int main() {
    init();

    int n = 6;
    mpt[1][2] = mpt[2][1] = 7;
    mpt[1][3] = mpt[3][1] = 4;
    mpt[2][3] = mpt[3][2] = 6;
    mpt[2][4] = mpt[4][2] = 2;
    mpt[2][6] = mpt[6][2] = 4;
    mpt[4][6] = mpt[6][4] = 7;
    mpt[3][6] = mpt[6][3] = 8;
    mpt[3][5] = mpt[5][3] = 9;
    mpt[5][6] = mpt[6][5] = 1;

    printf("%d\n", prim(1, n)); // 17
    return 0;
}
```

#### Kruskal

``` cpp
/*
 * Kruskal 算法，时间复杂度：O(M * logM)
 *
 * 思想：一开始所有的点都是独立的，将所有边按权值从小到达排列，然后依次判断边的两端是否在不同的集合中(使用并查集维护)，如果是则添加这条边到 mst
 */

#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
#define N 110
#define M 10010

struct Edge {
    int st, to, val; // 这里表示双向边
    bool operator<(const Edge &t) const {
        return val < t.val;
    }
} edge[M];

int f[N];

void init(int n) {
    for (int i = 1; i <= n; i++) {
        f[i] = i;
    }
}

int find(int x) {
    if (x != f[x]) f[x] = find(f[x]);
    return f[x];
}

bool un(int x, int y) {
    x = find(x);
    y = find(y);
    if (x != y) {
        f[x] = y;
        return 1;
    }
    return 0;
}

int kruskal(int n, int m) {
    int cnt = 0;
    int ans = 0;
    sort(edge + 1, edge + m + 1);
    for (int i = 1; i <= m; i++) {
        if (un(edge[i].st, edge[i].to)) {
            ans += edge[i].val;
            cnt++;
        }
    }
    if (cnt != n - 1) return -1;
    return ans;
}

int main() {
    int n = 6, m = 9;
    init(n);

    edge[1].st = 1, edge[1].to = 2, edge[1].val = 7;
    edge[2].st = 1, edge[2].to = 3, edge[2].val = 4;
    edge[3].st = 2, edge[3].to = 3, edge[3].val = 6;
    edge[4].st = 2, edge[4].to = 4, edge[4].val = 2;
    edge[5].st = 2, edge[5].to = 6, edge[5].val = 4;
    edge[6].st = 4, edge[6].to = 6, edge[6].val = 7;
    edge[7].st = 3, edge[7].to = 6, edge[7].val = 8;
    edge[8].st = 3, edge[8].to = 5, edge[8].val = 9;
    edge[9].st = 5, edge[9].to = 6, edge[9].val = 1;
    printf("%d\n", kruskal(n, m));
    return 0;
}
```

###次小生成树

### 最小树形图

## 最短路

## 连通图

## 匹配

## 查分约束

## 网络流

## 其他

### 拓扑排序

``` cpp
// TODO
```

# 字符串

## Manacher

## KMP

## AC自动机

## 后缀数组



