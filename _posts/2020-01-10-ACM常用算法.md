---
title: ACM常用算法
key: 980713e7e4adb5d20d75696b9693bae0
tags: 学习
---

ACM 打酱油选手，开个大坑，用于复习已经忘了很久的 ACM 常用算法 ~

持续更新 ...

<!--more-->

# 模拟

## 简单

## 复杂

# 贪心

# 搜索

## DFS

## BFS

## 记忆化

# 动态规划

## 背包问题

## 区间DP

## 树形DP

## 状压DP

## 数位DP

# 数学

## GCD

## 素数筛

## 容斥原理

## 鸽巢原理

## 扩展欧几里得

## 逆元

## 中国剩余定理

## 卢卡斯定理

## 欧拉函数

## 高斯消元

## 莫比乌斯反演

# 数据结构

## 栈

## 队列

## 字典树

## RMQ

## 线段树

## 并查集

## 树状数组

## 单调队列-栈
### 单例队列
#### 介绍
单调队列是一种广泛应用的数据结构，它能够动态地维护序列中的最值

#### 实例
设计一个队列，使得能够处理三种操作：
- PUSH 100  将元素100添加到队尾
- MAX  查询当前队列中元素的最大值
- POP  移除队首元素

#### 暴力解法
最简单的做法就是每次查询时遍历当前队列中的所有元素，比较得到最大值，复杂度：O(N\*K)，K为每次查询时队列的平均长度
比如：

|Operation|Comment（左边为队首，单调递减队列，队首为最大值）|
|---|:-----|
|PUSH 300|[300]|
|MAX|(1) 遍历得到当前最大值为300|
|PUSH 200|[300,200]|
|MAX|(2) 遍历得到当前最大值为300|
|PUSH 100|[300,200,100]|
|MAX|(3) 遍历得到当前最大值为300|
|POP|[200,100]|
|MAX|(4) 遍历得到当前最大值为200|
|PUSH 400|[200,100,400]|
|MAX|(5) 遍历得到当前最大值为400|
|POP|[100,400]|
|MAX|(6) 遍历得到当前最大值为400|

显然这不是最优解
先看第(1)(2)(3)(4)次查询，其实是可以省略一些比较运算的，因为进队的元素是单调递减的，无需比较直接返回队首元素即可（即使中间有出队操作）
再看第(5)次查询，插入的400破坏了前面的单调关系，是否可以将队列中的已有的200、100直接出队（因为这俩已经没用了，只要400被插入到队列中，最大值就永远不会是200或100，即使400被移除队列，200或100肯定先于400被移除），然后再将400进队，这样最大值就是队首元素了
综合上面两种情况：如果插入的元素满足单调关系，直接将元素插入队尾，否则先将队尾元素出队，再插入新的元素，查询时直接返回队首元素即可

#### 单调队列
单调队列相对于普通队列而言，需要维护了一种单调关系，队首始终保存的是当前队列中元素的最值
每个元素仅进队一次，仅出队一次，在元素插入队尾前，需要先和队尾元素进行比较，如果关系符合单调顺序，则直接插入队尾，否则需要先移除队尾元素再进行插入，使得始终保持单调关系
复杂度：O(N)

|Operation|Comment|
|---|:-----|
|PUSH 300|[300]|
|MAX|无需遍历，直接返回队首元素300|
|PUSH 200|[300,200] 200小于300，直接插入队尾|
|MAX|无需遍历，直接返回队首元素300|
|PUSH 100|[300,200,100] 100小于200，直接插入队尾|
|MAX|无需遍历，直接返回队首元素300|
|POP|[200,100] 移除队首元素|
|MAX|无需遍历，直接返回队首元素200|
|PUSH 400|[400]，400不小于100，移除队尾元素100，继续比较，400不小于200，再移除队尾元素200，最后将400插入队尾|
|MAX|无需遍历，直接返回队首元素400|
|POP|[400]，注意这里POP原本出队的是元素200，所以这里不需要真正执行出队操作。实际实现时可以给每个进队元素内置一个in_id，每次出队维护一个out_id++，如果当前out_id和队首元素的id相等，才真正执行出队操作|
|MAX|无需遍历，直接返回队首元素400|

##### 代码
``` cpp
// 未经测试，仅供参考
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 1000010

struct item {
    int id, val;
} q[MAXN], tp;

int main() {
    char op[10];
    int front = 0, rear = 0;
    int in = 0, out = 0; // in, out表示进队、出队编号
    while (scanf("%s", op) && strcmp(op, "END")) {
        if (strcmp(op, "PUSH") == 0) { // 进队，单调递减
            scanf("%d", &tp.val);
            tp.id = in++;
            while (rear > front && tp.val >= q[rear].val) rear--;
            q[rear++] = tp;
        } else if (strcmp(op, "MAX") == 0) { // 查询
            if (front == rear) {
                cout << -1 << endl;
            } else {
                cout << q[front].val << endl;
            }
        } else { // 出队，如果id在当前队首就出队
            if (out == q[front].id) {
                front++;
            }
            out++;
        }
    }
    return 0;
}
```

#### 题目
- FZU 1894  模板题
- POJ 2823  模板题
- HDU 3415
- HDU 3530
- POJ 3061

### 单调栈

#### 介绍

和单调队列类似，栈内元素始终保持单调性，不同的是单调栈只能在栈顶操作

将一个元素压入单调栈时，为了维护栈的单调性，需要和栈顶元素进行比较，栈顶始终保存的是当前栈中元素的最值

比如单调递减栈（从栈底到栈顶单调递减），每个元素进栈时，如果栈顶元素比当前元素大则直接进栈，否则需要先不断弹出栈顶元素直到栈顶元素大于当前元素，然后再压入当前元素

利用这一性质，可以利用单调栈：

- 求每个元素左边第一个比它大（单调递减）/ 小（单调递增）的元素
- 求每个元素左边的元素中以当前元素为右边第一个比其大（单调递减）或小（单调递增）的元素列表

#### 实例

|Operation|Comment（右边为栈顶，从栈底到栈顶单调递减，栈顶为最小值）|
|---|:-----|
|6|[6]|
|10|[10] 10大于6，弹出栈顶元素6，压入元素10|
|3|[10,3] 3小于10，压入元素3，3|
|7|[10,7] 7大于3，弹出栈顶元素3，压入元素7<br />比如这里可以得出：7左边第一个比7大的元素是栈顶元素10|
|4|[10,7,4] 4小于7，压入元素4|
|12|[12] 12大于10,7,4 弹出栈顶元素，压入元素12<br />比如这里可以得出：12左边的元素中，有三个元素10,7,4(递减序列)，他们右边的第一个比其大的元素是12|
|2|[12,2] 2小于12，压入元素2|

|Operation|Comment（右边为栈顶，从栈底到栈顶单调递增，栈顶为最大值）|
|---|:-----|
|6|[6]|
|10|[6,10] 10大于6，压入元素10|
|3|[3] 3小于6,10，弹出栈顶元素，压入元素3|
|7|[3,7] 7大于3，压入元素7|
|4|[3,4] 4小于7，弹出栈顶元素7，压入元素4|
|12|[3,4,12] 12大于4，压入元素12|
|2|[2] 2小于3,4,12，弹出栈顶元素，压入元素2|

#### 代码

``` cpp
// 未经测试，仅供参考
#include <iostream>
#include <cstdio>
#include <cstring>
#include <stack>
#include <algorithm>
using namespace std;

struct item {
    int id, val;
} tp;

// 7 6 10 3 7 4 12 2
int main() {
    int n;
    stack<item> s;
    while (scanf("%d", &n) != EOF) {
        for (int i = 0; i < n; i++) {
            tp.id = i;
            scanf("%d", &tp.val);
            while (s.size() > 0 && tp.val >= s.top().val) { // 从栈底到栈顶单调递减
                s.pop();
            }
            cout << "left first: " << (s.size() > 0 ? s.top().val : -1) << ", left size: " << s.size() << endl;
            s.push(tp);
        }
    }
    return 0;
}
```



#### 题目

- POJ 3250 模板题
- POJ 2796
- HDU 1506
- POJ 2559


## 树链剖分

## 划分树

## Treap

## Splay

## 主席树

# 图论

## 最短路

## 生成树

## 连通图

## 匹配

## 查分约束

## 网络流

## 其他

# 字符串

## Manacher

## KMP

## AC自动机

## 后缀数组



