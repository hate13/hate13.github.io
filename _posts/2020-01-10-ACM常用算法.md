---
title: ACM常用算法
key: 980713e7e4adb5d20d75696b9693bae0
tags: 学习
---

[ACM](https://zh.wikipedia.org/zh-sg/%E5%9B%BD%E9%99%85%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B) 打酱油选手，简单复习一下已经忘了很久的常用算法

![acm](http://118.24.108.205:8086/pic/blog/acm.jpg)

<!--more-->

# 基础算法

## 枚举

有些问题不好直接求解答案，但是若给出答案，很容易验证答案是否正确，此时就可以枚举答案范围内的所有值进行验证

## 模拟

### 简单

### 复杂

## 递归

## 分治

## 前缀和

前缀和是一种预处理手段，在某些情况能大大降低查询的时间复杂度

ps: 下标从 1 开始要好写一点，不用刻意处理数组边界

### 一维

``` c
// 一维：sum[i] 表示前 i 项的和
// 递推：sum[i] = sum[i - 1] + a[i]
// 查询：sum[l..r] = sum[1..r] - sum[1..l - 1]
void pre_solve_one() {
    int n = 5;
    int data[] = {0, 1, 5, 3, 2, 6}; // 1..5

    int sum[N] = {0};
    for (int i = 1; i <= n; i++) {
        sum[i] = sum[i - 1] + data[i];
    }

    // sum[1..5] = sum[5] - sum[0] = 17
    // sum[3..5] = sum[5] - sum[2] = 11
    printf("%d %d\n", sum[5], sum[5] - sum[2]);
}
```

### 二维

``` c
#include <stdio.h>
#define N 100

// 二维：sum[i][j] 表示从左上角 (1,1) 开始到坐标 (i, j) 之间的元素和
// 递推：sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + a[i][j] - sum[i - 1][j - 1]
// 查询：sum[(x1,y1)..(x2,y2)] = sum[x2][y2] - sum[x1-1][y2] - sum[x1][y2-1] + sum[x1-1][y1-1]
//
// 举例：
// (1,1) | (1,2) (1,3) (1,4)
// (2,1) | (2,2) (2,3) (2,4)
// (3,1) | (3,2) (3,3) (3,4)
// -------------------
// (4,1) | (4,2) (4,3) (4,4)
// (5,1) | (5,2) (5,3) (5,4)
//
// sum[(4,2)..(5,3)]
//  = sum[(1,1)..(5,3)] - sum[(1,1)..(3,3)] - sum[(1,1)..(5,1)] + sum[(1,1)..(3,1)]
//  = sum[5][3] - sum[3][3] - sum[5][1] + sum[3][1]
void pre_solve_two() {
    int n = 5, m = 4;
    int data[][5] = {
            {},
            {0, 1,  2,  3,  4},
            {0, 5,  6,  7,  8},
            {0, 9,  10, 11, 12},
            {0, 13, 14, 15, 16},
            {0, 17, 18, 19, 20},
    };
    int sum[N][N] = {0};
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + data[i][j] - sum[i - 1][j - 1];
        }
    }
    printf("%d %d\n", sum[5][4], sum[5][3] - sum[3][3] - sum[5][1] + sum[3][1]); // 210 66
}
```

### 树

``` c
// 树上前缀和：sum[i] 表示从根节点到节点 i 之间的路径权值和
// 如果是边权，sum(x..y) = sum[x] + sum[y] - 2 * sum[lca(x, y)]
// 如果是点权，sum(x..y) = sum[x] + sum[y] - 2 * sum[fa[lca(x, y)]] + data[lca(x, y)]
//
// 举例：
//     1
//    / \
//   2   3
//  / \
// 4   5
//      \
//       6
void pre_solve_tree() {

}
```

## 倍增

## 二指针

## 二分

### 二分查找

在网上搜索二分查找，可以看到各式各样的写法，其中一些写法是有问题的，参考：[二分查找有几种写法](https://www.zhihu.com/question/36132386)

推荐下面这种“左开右闭”的写法，另外注意二分查找的前提是数组有序

``` c
#include <stdio.h>

// 二分查找
// 若存在返回下标，否则返回-1
// 分析
//   如果 key = data[m]，表示找到了直接返回
//   如果 key < data[m]，表示 key 可能位于左区间 [l, m)
//   如果 key > data[m]，表示 key 可能位于右区间 [m + 1, r)
int binarySearch(int data[], int n, int key) {
    int l = 0, r = n;
    while (l < r) {
        int m = (l + r) >> 1; // 防溢出：l + ((r - l) >> 1)
        if (key == data[m]) {
            return m;
        } else if (key < data[m]) {
            r = m;
        } else {
            l = m + 1;
        }
    }
    return -1;
}

// 返回 >= key 的首个元素下标
// 区间左开右闭，比如：[l......m......r)
// 分析：
//   如果 key <= data[m]，首个大于等于 key 的首个元素一定位于 [l, m]，继续查找左区间 [l, m)。如果最终 [l, m) 中的元素都小于 key 咋办？没关系，这会使得二分过程中 l 不断向右 (即 m) 逼近，最终 "l = m + 1" 使得 l = m
//   如果 key >  data[m]，左区间 [l, m] 都比 key 小，不可能了，继续查找右区间 [m+1, r)
//
// 这种情况下，可能最后不存在 key，不断逼近，l 停止的位置就是刚好大于 key 的数的位置
int lowerBound(int data[], int n, int key) {
    int l = 0, r = n;
    while (l < r) {
        int m = (l + r) >> 1;
        if (key <= data[m]) {
            r = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}

// 返回 > key 的首个元素下标
// 区间左开右闭，比如：[l......m......r)
// 分析：
//   如果 key >= data[m]，答案显然不可能位于 [l, m]，继续查找右区间 [m+1, r)
//   如果 key  < data[m]，则答案一定位于 [l, m]，继续查找左区间 [l, m)。如果最终 [l, m) 中的元素都小于 key 咋办？同上
//
// 在这种情况下，停止时 l 一定是 key 后面，可能存在 key，也可能不存在 key
int upperBound(int data[], int n, int key) {
    int l = 0, r = n;
    while (l < r) {
        int m = (l + r) >> 1;
        if (key >= data[m]) {
            l = m + 1;
        } else {
            r = m;
        }
    }
    return l;
}

int main() {
    int data[] = {1, 2, 3, 3, 3, 6, 6, 8, 9, 10};
    printf("%d %d\n", binarySearch(data, 10, 5), binarySearch(data, 10, 8)); // -1 7
    printf("%d %d\n", lowerBound(data, 10, 3), lowerBound(data, 10, 5)); // 2 5
    printf("%d %d\n", upperBound(data, 10, 3), upperBound(data, 10, 6)); // 5 7
    return 0;
}
```

### 二分答案

参考上面的[枚举](https://hate13.com/2020/01/10/ACM%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.html#%E6%9E%9A%E4%B8%BE)，如果答案满足一定单调性，则可以通过二分优化

``` c
#include <stdio.h>

bool check(int n) {
    return true;
}

int find(int l, int r) {
    while (l < r) {
        int m = (l + r) >> 1;
        if (check(m)) {
           // ans = m; // 可能有时不太好处理这种左开右闭写法的边界问题，干脆直接加一个 ans 变量记录答案
            r = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}
```

## 排序

# 贪心

# 搜索

## DFS

## BFS

## 记忆化

# 动态规划

## 背包问题

## 区间DP

## 树形DP

## 状压DP

## 数位DP

# 数学

## GCD

## 素数筛

## 容斥原理

## 鸽巢原理

## 快速幂

### 乘法快速幂

``` c
#include <stdio.h>

// 快速计算 a^n，复杂度 O(logN)
//
// 一般循环遍历相乘需要做 n 次乘法，如果 n 太大就比较慢了
// 那么可以做一个变换，将 n 用二进制表示，如：a^13 = a^(1101)_2 = a^8 * a^4 * 1 * a^1
// 这样就可以优化计算了，将 n 转化为二进制，从低位到高位，如果这一位为1，则乘上 a，同时每次循环 a 都自乘一次
int quick_pow(int a, int b) {
    int ret = 1;
    while (b) {
        if (b & 1) ret *= a;
        a *= a;
        b >>= 1;
    }
    return ret;
}

int main() {
    printf("%d\n", quick_pow(3, 13));
    return 0;
}
```

### 矩阵快速幂

## 扩展欧几里得

## 逆元

## 中国剩余定理

## 卢卡斯定理

## 欧拉函数

## 高斯消元

## 莫比乌斯反演

# 数据结构

## 栈

## 队列

## 字典树

## RMQ

## 线段树

## 并查集

## 树状数组

## 单调队列-栈
### 单例队列
#### 介绍
单调队列是一种广泛应用的数据结构，它能够动态地维护序列中的最值

#### 实例
设计一个队列，使得能够处理三种操作：
- PUSH 100  将元素100添加到队尾
- MAX  查询当前队列中元素的最大值
- POP  移除队首元素

#### 暴力解法
最简单的做法就是每次查询时遍历当前队列中的所有元素，比较得到最大值，复杂度：O(N\*K)，K为每次查询时队列的平均长度  
比如：

|Operation|Comment（左边为队首，单调递减队列，队首为最大值）|
|---|:-----|
|PUSH 300|[300]|
|MAX|(1) 遍历得到当前最大值为300|
|PUSH 200|[300,200]|
|MAX|(2) 遍历得到当前最大值为300|
|PUSH 100|[300,200,100]|
|MAX|(3) 遍历得到当前最大值为300|
|POP|[200,100]|
|MAX|(4) 遍历得到当前最大值为200|
|PUSH 400|[200,100,400]|
|MAX|(5) 遍历得到当前最大值为400|
|POP|[100,400]|
|MAX|(6) 遍历得到当前最大值为400|

显然这不是最优解  
先看第(1)(2)(3)(4)次查询，其实是可以省略一些比较运算的，因为进队的元素是单调递减的，无需比较直接返回队首元素即可（即使中间有出队操作）  
再看第(5)次查询，插入的400破坏了前面的单调关系，是否可以将队列中的已有的200、100直接出队（因为这俩已经没用了，只要400被插入到队列中，最大值就永远不会是200或100，即使400被移除队列，200或100肯定先于400被移除），然后再将400进队，这样最大值就是队首元素了  
综合上面两种情况：如果插入的元素满足单调关系，直接将元素插入队尾，否则先将队尾元素出队，再插入新的元素，查询时直接返回队首元素即可

#### 单调队列
单调队列相对于普通队列而言，需要维护了一种单调关系，队首始终保存的是当前队列中元素的最值  
每个元素仅进队一次，仅出队一次，在元素插入队尾前，需要先和队尾元素进行比较，如果关系符合单调顺序，则直接插入队尾，否则需要先移除队尾元素再进行插入，使得始终保持单调关系  
复杂度：O(N)

|Operation|Comment|
|---|:-----|
|PUSH 300|[300]|
|MAX|无需遍历，直接返回队首元素300|
|PUSH 200|[300,200] 200小于300，直接插入队尾|
|MAX|无需遍历，直接返回队首元素300|
|PUSH 100|[300,200,100] 100小于200，直接插入队尾|
|MAX|无需遍历，直接返回队首元素300|
|POP|[200,100] 移除队首元素|
|MAX|无需遍历，直接返回队首元素200|
|PUSH 400|[400]，400不小于100，移除队尾元素100，继续比较，400不小于200，再移除队尾元素200，最后将400插入队尾|
|MAX|无需遍历，直接返回队首元素400|
|POP|[400]，注意这里POP原本出队的是元素200，所以这里不需要真正执行出队操作。实际实现时可以给每个进队元素内置一个in_id，每次出队维护一个out_id++，如果当前out_id和队首元素的id相等，才真正执行出队操作|
|MAX|无需遍历，直接返回队首元素400|

##### 代码
``` cpp
// 未经测试，仅供参考
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 1000010

struct item {
    int id, val;
} q[MAXN], tp;

int main() {
    char op[10];
    int front = 0, rear = 0;
    int in = 0, out = 0; // in, out表示进队、出队编号
    while (scanf("%s", op) && strcmp(op, "END")) {
        if (strcmp(op, "PUSH") == 0) { // 进队，单调递减
            scanf("%d", &tp.val);
            tp.id = in++;
            while (rear > front && tp.val >= q[rear].val) rear--;
            q[rear++] = tp;
        } else if (strcmp(op, "MAX") == 0) { // 查询
            if (front == rear) {
                cout << -1 << endl;
            } else {
                cout << q[front].val << endl;
            }
        } else { // 出队，如果id在当前队首就出队
            if (out == q[front].id) {
                front++;
            }
            out++;
        }
    }
    return 0;
}
```

#### 题目
- FZU 1894  模板题
- POJ 2823  模板题
- HDU 3415
- HDU 3530
- POJ 3061

### 单调栈

#### 介绍

和单调队列类似，栈内元素始终保持单调性，不同的是单调栈只能在栈顶操作

将一个元素压入单调栈时，为了维护栈的单调性，需要和栈顶元素进行比较，栈顶始终保存的是当前栈中元素的最值

比如单调递减栈（从栈底到栈顶单调递减），每个元素进栈时，如果栈顶元素比当前元素大则直接进栈，否则需要先不断弹出栈顶元素直到栈顶元素大于当前元素，然后再压入当前元素

利用这一性质，可以利用单调栈：

- 求每个元素左边第一个比它大（单调递减）/ 小（单调递增）的元素
- 求每个元素左边的元素中以当前元素为右边第一个比其大（单调递减）或小（单调递增）的元素列表

#### 实例

|Operation|Comment（右边为栈顶，从栈底到栈顶单调递减，栈顶为最小值）|
|---|:-----|
|6|[6]|
|10|[10] 10大于6，弹出栈顶元素6，压入元素10|
|3|[10,3] 3小于10，压入元素3，3|
|7|[10,7] 7大于3，弹出栈顶元素3，压入元素7<br />比如这里可以得出：7左边第一个比7大的元素是栈顶元素10|
|4|[10,7,4] 4小于7，压入元素4|
|12|[12] 12大于10,7,4 弹出栈顶元素，压入元素12<br />比如这里可以得出：12左边的元素中，有三个元素10,7,4(递减序列)，他们右边的第一个比其大的元素是12|
|2|[12,2] 2小于12，压入元素2|

|Operation|Comment（右边为栈顶，从栈底到栈顶单调递增，栈顶为最大值）|
|---|:-----|
|6|[6]|
|10|[6,10] 10大于6，压入元素10|
|3|[3] 3小于6,10，弹出栈顶元素，压入元素3|
|7|[3,7] 7大于3，压入元素7|
|4|[3,4] 4小于7，弹出栈顶元素7，压入元素4|
|12|[3,4,12] 12大于4，压入元素12|
|2|[2] 2小于3,4,12，弹出栈顶元素，压入元素2|

#### 代码

``` cpp
// 未经测试，仅供参考
#include <iostream>
#include <cstdio>
#include <cstring>
#include <stack>
#include <algorithm>
using namespace std;

struct item {
    int id, val;
} tp;

// 7 6 10 3 7 4 12 2
int main() {
    int n;
    stack<item> s;
    while (scanf("%d", &n) != EOF) {
        for (int i = 0; i < n; i++) {
            tp.id = i;
            scanf("%d", &tp.val);
            while (s.size() > 0 && tp.val >= s.top().val) { // 从栈底到栈顶单调递减
                s.pop();
            }
            cout << "left first: " << (s.size() > 0 ? s.top().val : -1) << ", left size: " << s.size() << endl;
            s.push(tp);
        }
    }
    return 0;
}
```



#### 题目

- POJ 3250 模板题
- POJ 2796
- HDU 1506
- POJ 2559


## 树链剖分

## 划分树

## Treap

## Splay

## 主席树

# 图论

## 最短路

## 生成树

## 连通图

## 匹配

## 查分约束

## 网络流

## 其他

# 字符串

## Manacher

## KMP

## AC自动机

## 后缀数组



