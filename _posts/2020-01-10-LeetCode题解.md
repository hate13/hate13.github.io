---
title: LeetCode题解
key: bd9f8354e36d802c130188b2cbdc086c
tags: 学习
---

记录一下做过的 LeetCode ~

持续更新...

<!--more-->

## [62-不同路径](https://leetcode-cn.com/problems/unique-paths/)

最简单的动态规划了，$dp[i][j]=dp[i-1][j] + dp[i][j-1]$

``` c
#include <string.h>
#define MAXN 111

int dp[MAXN][MAXN];

int uniquePaths(int n, int m) {
    memset(dp, 0, sizeof(dp));
    dp[1][1] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (i - 1 >= 1) {
                dp[i][j] += dp[i - 1][j];
            }
            if (j - 1 >= 1) {
                dp[i][j] += dp[i][j - 1];
            }
        }
    }
    return dp[n][m];
}
```

## [72-编辑距离](https://leetcode-cn.com/problems/edit-distance/)

动态规划，$dp[i][j] 表示 s1[0~i] 变换为 s2[0~j] 的最小次数$ TODO

``` cpp
#include <string.h>
#define min(a,b) ((a)<(b)?(a):(b))
#define MAXN 1010
int dp[MAXN][MAXN];

int minDistance(char* s1, char* s2){
    int l1 = strlen(s1);
    int l2 = strlen(s2);

    // 0~i
    // 0~j
    for (int i = 0; i <= l1; i++)
        dp[i][0] = i;
    for (int i = 0; i <= l2; i++)
        dp[0][i] = i;
    for (int i = 1; i <= l1; i++) {
        for (int j = 1; j <= l2; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]) + 1);
            } else {
                dp[i][j] = min(dp[i - 1][j - 1] /* 替换 */, min(dp[i - 1][j], dp[i][j - 1]) /* 插入  | 删除 */) + 1;
            }
        }
    }

    return dp[l1][l2];
}
```

## [124-二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

递归，如果路径和小于0则丢弃。最大路径要么：

- 跨子树根节点：左子树 + 右子树 + 当前节点权值
- 不跨子树根节点：左子树 或 右子树的最大值 + 当前节点权值

``` c
#define INF 0x3f3f3f3f

int ans;

int max(int a, int b) {
    return a > b ? a : b;
}

int dfs(struct TreeNode* root) {
    int left = 0, right = 0;
    if (root->left != NULL) {
        left = max(dfs(root->left), 0);
    }
    if (root->right != NULL) {
        right = max(dfs(root->right), 0);
    }
    ans = max(ans, left + right + root->val);
    return max(left, right) + root->val;
}

//      5
//    4  8
//  11  13 4
// 7 2      1
int maxPathSum(struct TreeNode* root) {
    ans = -INF;
    dfs(root);
    return ans;
}
```

## [233-数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/)

数位DP模板题，参考：[数位DP](https://hate13.com/2020/01/10/ACM常用算法.html#数位dp)

``` cpp
#define N 100
int bit[N]; // 13 => 3 1
int dp[N][N];

int dfs(int pos, int num, bool limit, bool fzero) {
    if (pos == -1) {
        return num;
    }
    if (!limit  && !fzero && dp[pos][num] != -1) {
        return dp[pos][num];
    }
    int ans = 0;
    int end = limit ? bit[pos] : 9;
    for (int i = 0; i <= end; i++) {
        int num1 = num + (i == 1);
        ans += dfs(pos - 1, num1, limit && i == end, !i && fzero);
    }
    if (!limit && !fzero) dp[pos][num] = ans;
    return ans;
}

int countDigitOne(int n) {
    int l = 0;
    while (n) {
        bit[l++] = n % 10;
        n /= 10;
    }
    memset(dp, -1, sizeof(dp));
    return dfs(l - 1, 0, true, true);
}
```

## [239-滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

单调队列模板题，详情：[单调队列-栈](https://hate13.com/2020/01/10/ACM常用算法.html#单调队列-栈)

``` go
func maxSlidingWindow(nums []int, k int) []int {
    type Item struct {
        id  int
        val int
    }
    res := make([]int, 0, len(nums));
    queue := make([]Item, len(nums))
    in, out := 0, 0
    front, rear := 0, 0
    for _, num := range nums {
        for rear > front && num >= queue[rear - 1].val { // 递减
            rear--
        }
        queue[rear] = Item{in, num} // 进队
        rear++
        in++
        if in - out == k { // k个元素，出队
            res = append(res, queue[front].val)
            if out == queue[front].id {
                front++
            }
            out++
        }
    }
    return res;
}
```

## [404-左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

简单题目，注意由于需要判断是否是左叶子

- 默认情况下不能遍历到叶子节点（叶子节点不知道自己是否是左叶子），所以需要在叶子节点的父节点进行判断
- 或者向下带上一个参数，表示是否是左儿子节点

```python
class Solution(object):
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        return self.cal(root)
        return self.cal2(root, False)
        
    def cal(self, node):
        if node is None:
            return 0

        res = 0
        if node.left is not None and node.left.left is None and node.left.right is None:  # 左叶子
            res = node.left.val
            
        return self.cal(node.left) + self.cal(node.right) + res

    def cal2(self, node, is_left):
        if node is None:
            return 0

        if is_left and node.left is None and node.right is None:
            return node.val

        return self.cal2(node.left, True) + self.cal2(node.right, False)
```

## [547-朋友圈](https://leetcode-cn.com/problems/friend-circles/)

简单搜索一下就行，判断是否所有节点都可达，也可以使用并查集

``` java
class Solution {
    public int findCircleNum(int[][] input) {
        int n = input.length;
        boolean vis[] = new boolean[n];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                dfs(i, n, input, vis);
                ans++;
            }
        }
        return ans;
    }

    private void dfs(int s, int n, int[][] input, boolean vis[]) {
        vis[s] = true;
        for (int t = 0; t < n; t++) {
            if (input[s][t] > 0 && !vis[t]) {
                dfs(t, n, input, vis);
            }
        }
    }
}
```

## [605-种花问题](https://leetcode-cn.com/problems/can-place-flowers/)

简单贪心问题，如果当前能种则种即可

``` python
class Solution(object):
    def canPlaceFlowers(self, flowerbed, n):
        """
        :type flowerbed: List[int]
        :type n: int
        :rtype: bool
        """
        last = -2
        count = 0
        flowerbed.append(0)
        for i, c in enumerate(flowerbed):
            if c == 1:
                last = i
            if c == 0 and i - last > 1 and i + 1 < len(flowerbed) and flowerbed[i + 1] != 1:
                count += 1
                last = i
        return count >= n
```

## [647-回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

以每个节点为中心，向两边扩展即可，需要分为奇数位和偶数位两种情况

- 这里的解法有优化的空间
- 应该还有更优的解法

``` c
int count(char *s, int l, int r, int n) {
    int c = 0;
    while (l >= 0 && r < n && s[l] == s[r]) l--, r++, c++;
    return c;
}

int countSubstrings(char * s) {
    int n = strlen(s);
    int ans = 0;
    for (int i = 0; i < n; i++) {
        ans += count(s, i, i, n); // 212
        ans += count(s, i, i + 1, n); // 2112
    }
    return ans;
}
```

## [695-岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

简单搜索一下就行了，取最大值

``` java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;

        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 1) {
                    ans = Math.max(ans, dfs(i, j, n, m, grid));
                }
            }
        }
        return ans;
    }

    // 1 1 0 0 0
    // 1 1 0 0 0
    // 0 0 0 1 1
    // 0 0 0 1 1
    int dir[][] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    int dfs(int x, int y, int n, int m, int[][] grid) {
        int area = 1;
        grid[x][y] = 0;
        for (int i = 0; i < dir.length; i++) {
            int tx = x + dir[i][0];
            int ty = y + dir[i][1];
            if (tx < 0 || tx >= n || ty < 0 || ty >= m || grid[tx][ty] == 0) {
                continue;
            }
            area += dfs(tx, ty, n, m, grid);
        }
        return area;
    }
}
```

## [743-网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

随表搜一搜就行了，判断是否可达，如果同一个节点有多个路径可达取最小值

``` java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        // build
        List<Edge>[] g = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            g[i] = new ArrayList<Edge>();
        }
        for (int i = 0; i < times.length; i++) {
            int u = times[i][0];
            int v = times[i][1];
            int w = times[i][2];
            g[u].add(new Edge(v, w));
        }
      
        // process
        int dp[] = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = -1; // unreachable
        }
        dfs(k, k, 0, g, dp);
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (dp[i] == -1) {
                return -1;
            }
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }

    private void dfs(int u, int pre, int time, List<Edge>[] g, int dp[]) {
        if (dp[u] == -1) {
            dp[u] = time;
        } else {
            if (time >= dp[u]) {
                return;
            }
            dp[u] = time;
        }
        for (int i = 0; i < g[u].size(); i++) {
            int v = g[u].get(i).v;
            int w = g[u].get(i).w;
            if (v == pre) {
                continue;
            }
            dfs(v, u, time + w, g, dp);
        }
    }

    static class Edge {
        public int v;
        public int w;

        public Edge(){}
        public Edge(int v, int w) {
            this.v = v;
            this.w = w;
        }
    }
}
```

## [991-坏了的计算器](https://leetcode-cn.com/problems/broken-calculator/)

贪心问题，从结果倒推，如果是奇数就加一，否则除以2，直到小于等于原始值，再补上一个差值即可

``` java
class Solution {
    public int brokenCalc(int x, int y) {
        // 5 => 8
        // 5 => 4 => 8

        // 5 => 7
        // 5 => 4 => 8 => 7  7=8-1  
        // 5 => 10 => 9 => 8 => 7

        // 3 => 10
        // 3 => 6 => 5 => 10

        int count = 0;
        while (y > x) {
            if (y % 2 == 1) {
                y += 1;
            } else {
                y /= 2;
            }
            count++;
        }
        return count + (x - y);
    }
}
```

## [1003-检查替换后的词是否有效](https://leetcode-cn.com/problems/check-if-word-is-valid-after-substitutions/)

简单题目，不断删除abc，判断是否可以全部被删除

``` c
#define MAXN 20010

int top;
char stack[MAXN];

bool isValid(char *s) {
    int n = strlen(s);
    top = 0;
    for (int i = 0; i < n; i++) {
        stack[top++] = s[i];
        // aabc bc
        while (top >= 3 
            && stack[top - 1] == 'c' 
            && stack[top - 2] == 'b'
            && stack[top - 3] == 'a') {
                top -= 3;
        }
    }
    return top == 0;
}
```

## [1137-第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

递推一下就行了

``` python
class Solution(object):
    def tribonacci(self, n):
        """
        :type n: int
        :rtype: int
        """
        ret = [0, 1, 1]
        
        i = 3
        while i <= n:
            ret.append(ret[i - 1] + ret[i - 2] + ret[i - 3])
            i += 1
        
        return ret[n]
```

## [1219-黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)

从每个点开始搜索一遍就行了

``` java
class Solution {
    int dir[][] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    public int getMaximumGold(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        
        int ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                ans = Math.max(ans, dfs(i, j, n, m, grid));
            }
        }
        // ans = dfs(2, 1, n, m, grid);
        return ans;
    }

    // 0 6 0
    // 5 8 7
    // 0 9 0

    // 1, 0, 7 
    // 2, 0, 6
    // 3, 4, 5
    // 0, 3, 0
    // 9, 0, 20
    int dfs(int x, int y, int n, int m, int grid[][]) {
        int t = grid[x][y];
        int maxNext = 0;
        grid[x][y] = -1;
        for (int i = 0; i < dir.length; i++) {
            int tx = x + dir[i][0];
            int ty = y + dir[i][1];
            if (tx < 0 || tx >= n || ty < 0 || ty >= m || grid[tx][ty] <= 0) {
                continue;
            }
            maxNext = Math.max(maxNext, dfs(tx, ty, n, m, grid));
        }
        grid[x][y] = t;
        return maxNext + t;
    }
}
```

## [1254-统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)

简单的DFS搜一下就行，通过递归如果触及到边界则不是封闭岛屿

``` java
class Solution {
    private int dir[][] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    public int closedIsland(int[][] grid) {
        int ans = 0;
        int n = grid.length;
        int m = grid[0].length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 0) {
                    if (dfs(grid, n, m, i, j)) {
                        ans++;
                    }
                }
            }
        }
        return ans;
    }

    private boolean dfs(int[][] grid, int n, int m, int x, int y) {
        boolean status = true;
        if (x == 0 || y == 0 || x == n - 1 || y == m - 1) {
            status = false;
        }
        for (int i = 0; i < dir.length; i++) {
            int tx = x + dir[i][0];
            int ty = y + dir[i][1];
            if (tx < 0 || tx >= n || ty < 0 || ty >= m || grid[tx][ty] != 0) {
                continue;
            }
            grid[tx][ty] = 1;
            boolean ok = dfs(grid, n, m, tx, ty);
            if (!ok) {
                status = false;
            }
        }
        return status;
    }
}
```

## [1267-统计参与通信的服务器](https://leetcode-cn.com/problems/count-servers-that-communicate/)

简单题目，判断一下同一行和同一列的服务器数量是否大于2即可

```python
class Solution(object):
    def countServers(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        n, m = len(grid), len(grid[0])
        row = [0 for i in range(n)]
        col = [0 for i in range(m)]
        for i in range(n):
            for j in range(m):
                if grid[i][j] > 0:
                    row[i] += 1
                    col[j] += 1

        ans = 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] > 0:
                    if row[i] >= 2 or col[j] >= 2:
                        ans += 1

        return ans
```

## [1291-顺次数](https://leetcode-cn.com/problems/sequential-digits/)

简单模拟了一下，其实完全可以打表的

```java
class Solution {
    public List<Integer> sequentialDigits(int low, int high) {
        // 1000 130000
        // 1234
        // 2345
        // 3456
        // 4567
        // 5678
        // 6789
        // 
        // 10000
        //
        // 12345
        // 23456

        // 2000 9000
        // 2345

        List<Integer> ans = new ArrayList<>();

        int len_low = len(low);
        int len_high = len(high);
        for (int i = len_low; i <= len_high; i++) {
            int x = i == len_low ? highBit(low, len_low) : 1;
            for (int j = x; j <= 10 - i; j++) {
                int n = gen(i, j);
                if (n < low) {
                    continue;
                }
                if (n > high) {
                    break;
                }
                ans.add(gen(i, j));
            }
        }
        return ans;
    }

    private int highBit(int n, int len) {
        for (int i = 0; i < len - 1; i++) { // 1000 4
            n = n / 10;
        }
        return n;
    }

    private int len(int n) {
        // 101 => 3
        // 10 => 2
        // 8 => 1
        return (int) (Math.log10(n)) + 1;
    }

    private int gen(int len, int start) {
        // 4 + 2 => 2345
        int n = 0;
        for (int i = 0; i < len; i++) {
            n = n * 10 + start + i; // 2 => 23 ...
        }
        return n;
    }
}
```

